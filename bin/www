#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('node-rest:server');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

/******************************
 * Code for Socket.io handling
 *****************************/
var os = require('os');
var nodeStatic = require('node-static');
var socketIO = require('socket.io');
var fileServer = new(nodeStatic.Server)();
var io = socketIO.listen(server);
var users = [];

console.log('Server listening on port ' + port);

io.sockets.on('connection', function(socket) {
  function log() {
    var array = ['Message from server:'];
    array.push.apply(array, arguments);
    socket.emit('log', array);
  }

  socket.on('message', function(message) {
    log('Client said: ', message);
    // Broadcast for every user
    socket.broadcast.emit('message', message);

    // Room-only
    //socket.emit('message', message);
  });

  socket.on('presentation', function(username) {
    var index = 0;
    var user = {
      username: username,
      socket: socket
    };
    
    console.log('User ' + username + ' connected.');

    /********************
     * TODO: Verificar que no esté o en el on disconnect eliminar del array
     * ********************/
    
    //Añadimos el usuario a la lista global de usuarios.
    for (let userIterated of users) {
      if (userIterated.username === username) {
        
      console.log('User ' + username + ' is already in the list. Reassigning...')
        users[index] = user;
        return;
      }

      index++;
    }

    console.log('Adding user ' + username + ' to the list.')
    users.push(user);
  });

//La id solo estará disponible cuando el otro usuario esté conectado,
//puesto que se basa en los usuarios/sockets previamente conectados.
//Esto está bien porque sólo podremos hablar con los usuarios conectados. (A tener en cuenta).

//El usuario del socket está llamando al usuario con el nombre recibido por parámetro (calledName)

  socket.on('call', function (calledName) {
   // log('Received request to pick up ');
    console.log("Calling... Number of users: " + users.length);
    //Buscamos en la lista de usuarios el primer usuario con ese nombre (deben ser únicos)
    var foundUsers = users.filter(user => user.username === calledName);
    if (!foundUsers.length) {
      let strMsg = 'The user you\'re trying to call is disconnected';
      socket.emit('userdisconnected', calledName, strMsg);
      return;
    }

    var user = foundUsers[0];

    //Establecemos el string de la habitación concatenando la id del socket called con la del caller
    var room =  user.socket.id + "" + socket.id;
    console.log('User with ID:' + socket.id + ' is calling ' + calledName + '(' + user.socket.id + ')');
    
    socket.join(room);
    //Notificamos al usuario called de que se le está llamando
    socket.emit('calling' , room, socket.id);
    user.socket.emit('called' , room, socket.id);
  });

  //Una vez el usuario ha sido llamado y lo ha cogido se une a la habitación en cuestión
  socket.on('pickup', function (room, callerId) {
    var user = users.filter(user => user.socket.id === callerId)[0];
    if (!user) {
      return;
    }
    //TODO: IF NO USER, EMIT USERDISCONNECTED
    console.log('The call from ' + user.username + ' was answered');
    socket.join(room);

    //Emitimos el mensaje de que se ha cogido la llamada.
    //user.socket.emit('pickedup', room, socket.id);
    log('Client ID ' + socket.id + ' picked up the phone ' + room);
    io.sockets.in(room).emit('ready');
  });



  
  socket.on('rejectcall', function(callerId) {
    var user = findUserById(callerId);
    if (!user) {
      return;
    }
    
    user.socket.emit('rejectedcall');
  });  


  socket.on('cancelcall', function(calleeUsername) {
    var user = findUserByName(calleeUsername);
    if (!user) {
      return;
    }
    
    user.socket.emit('canceledcall');
  });  



  //On user disconnect
  socket.on('disconnect', function (room, username, reason) {
    var index = 0;
    //Removing the user that sent the disconnected message from the online users list.
    for (let user of users) {
      if (user.socket.id === this.id) {
        io.sockets.in(room).emit('userdisconnected');
        users.splice(index, 1);
        console.log('[USER DISCONNECT]: Online users (' + users.length + ')');
        return;
      }

      index++;
    }
  });
  
  socket.on('ipaddr', function() {
    var ifaces = os.networkInterfaces();
    for (var dev in ifaces) {
      ifaces[dev].forEach(function(details) {
        if (details.family === 'IPv4' && details.address !== '127.0.0.1') {
          socket.emit('ipaddr', details.address);
        }
      });
    }
  });
});


//Functions

function findUserById(id) {
  return users.filter(user => user.socket.id === id)[0];
}

function findUserByName(username) {
  return users.filter(user => user.username === username)[0];
}

function deleteUserById(id) {
  var index = 0;
  for (let user of users) {
    if (user.socket.id === id) {
      //io.sockets.in(room).emit('userdisconnected');
      users.splice(index, 1);
      return true;
    }

    index++;
  }

  return false;
}